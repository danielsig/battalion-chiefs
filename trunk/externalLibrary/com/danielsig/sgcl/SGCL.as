package com.danielsig.sgcl{	import com.danielsig.ArrayUtilPro;	import com.danielsig.SimpleEval;	import flash.geom.Point;		public class SGCL	{				private static const STACK_OVERFLOW : int = 40;		private var _source : XML;		private var _functions : Object;				public function SGCL(source : XML, functions : Object)		{			if(!(source && functions))			{				throw new Error("The folowing must be non null: " + (source ? "source" : "") + (functions ? (!source ? ", " : "") + "functions" : "") + ".");			}						_source = source;			_functions = functions;		}		public function run(geometryName : String = "Main", parameters : Object = null) : Object		{			if(!_source[geometryName].length())			{				throw new Error("Solid Geometry '" + geometryName + "' is undefined");				return null;			}			else			{				parameters = parameters || {};				return execute(_source[geometryName][0], parameters);			}		}		private function execute(target : XML, parameters : Object = null, recursive : Boolean = false) : Object		{			parameters = parameters || {};			var local : Object = {thisObj:{}};						//apply parameter defaults			for each(var defaultParam : XML in target.@*)			{				var paramName : String = defaultParam.name().localName;								if(!parameters.hasOwnProperty(paramName))				{					parameters[paramName] = parseValue(defaultParam, local);					local[paramName] = parameters[paramName];				}				else				{					local[paramName] = parameters[paramName];				}			}			//finding the function			if(_functions.hasOwnProperty(target.name().localName))			{				//call the function				local.thisObj = _functions[target.name().localName](parameters);			}			if(recursive)			{				return local;			}			processChildren(target, local)			return local.thisObj || null;		}		private function processChildren(target : XML, local : Object, index : int = -1) : Object		{			var breakNow : Boolean = false;			//for each child			var children : XMLList = target.children();			var numChildren : int = children.length();			for(var i : int = index > 0 ? index : 0; i < numChildren; i++)			{				var child : XML = children[i];				if(breakNow)				{					break;				}				var childName : String = child.name();				switch(childName)				{					case "if":						if(SimpleEval.Eval(child.@condition, true)(local))						{							processChildren(child, local);						}						break;					case "set":					case "this":						for each(var variable : XML in child.@*)						{							var varName : String = variable.name().localName;							if(local.thisObj.hasOwnProperty(varName))							{								local.thisObj[varName] = parseValue(variable, local);							}							else							{								local[varName] = parseValue(variable, local);							}						}						break;					case "return":						breakNow = true;						break;					case "debug":						for each(var log : XML in child.@*)						{							trace(log + " = " + parseValue(log, local));						}						break;					case "trace":						for each(var localVar : * in local)						{							trace((localVar.hasOwnProperty("name") ? localVar.name : typeof(localVar)) + " = " + localVar.toString());						}						trace("----------");						break;					case "clone":						if(!(local[child.@original] || local.prev))						{							throw Error("Can not make a clone, original is null:\n" + target);						}						else						{							var temp : Object = local[child.@original] || local.prev || local.thisObj;							if(_functions.clone)							{								temp = _functions.clone(temp);							}							else if(temp.clone)							{								temp = temp.clone();							}							else							{								throw Error("a clone() function has not been defined inside the " + typeof(temp) + "Class.\n Please define one or assign a generic clone function which takes the original object as an arguement:\n" + target);							}							applyProperties(temp, child.children(), local);							local.prev = temp						}						break;					case "error":						throw Error(child.@message + "\n\tat " + target.name());					default:						//is the child defined in sgcl						if(_source[childName].length())						{							//trace(childName + " = " + target.parent().name());							//is it a recursion							/*if(childName == target.parent().name())							{								if(index > -1)								{									return {index:i, nextParams:parseParameters(child.@*, local), local:local};								}								temp = executeRecursive(target, parseParameters(child.@*, local));								applyProperties(temp, child.children(), local);								local.prev = temp;							}							else							{*/								//execute child								temp = execute(_source[childName][0], parseParameters(child.@*, local));								applyProperties(temp, child.children(), local);								local.prev = temp;							//}						}						else if(local[childName])						{							for each(variable in child.@*)							{								local[childName][variable.name().localName] = parseValue(variable, local);							}						}						else						{							throw new Error("Solid Geometry '" + childName + "' is undefined:\n" + target.toXMLString());						}						break;				}			}			return null;		}		private function executeRecursive(target : XML, parameters : Object = null) : Object		{			var stack : Vector.<Object> = Vector.<Object>([{local:parameters, index:0}]);			for(var i : int = 0; i < STACK_OVERFLOW; i++)			{				var newLocal : Object = execute(target, stack[stack.length-1].local, true);				var info : Object = processChildren(target, newLocal, stack[stack.length-1].index);				if(info == null)				{					stack.pop();				}				else				{					stack[stack.length - 1].local = info.local;					stack[stack.length - 1].index = info.index;					stack.push({local:info.nextParams, index:0});				}			}			if(i == STACK_OVERFLOW)			{				throw new Error("SGCL Stack Overflow!");			}			return newLocal.thisObj;		}		private function applyProperties(obj : Object, code : XMLList, local : Object) : void		{			for each(var command : XML in code)			{				var comName : String = command.name();				switch(comName)				{					case "set":						for each(var variable : XML in command.@*)						{							var varName : String = variable.name().localName;							if(obj.hasOwnProperty(varName))							{								obj[varName] = parseValue(variable, local);							}							else							{								local[varName] = parseValue(variable, local);							}						}						break;					case "this":						for each(variable in command.@*)						{							varName = variable.name().localName;							if(local.thisObj.hasOwnProperty(varName))							{								local.thisObj[varName] = parseValue(variable, local);							}							else							{								local[varName] = parseValue(variable, local);							}						}						break;				}			}		}		private function parseValue(target : XML, local : Object) : *		{			return SimpleEval.Eval(target, true)(local);			if(/^([+-]?[0-9]*\.?[0-9]+|0x[0-9]+)$/.test(target))			{				return Number(target);			}			else if(/\^([+-]?[0-9]*\.?[0-9]+,[+-]?[0-9]*\.?[0-9]+\)$/.test(target))			{				var float : RegExp = /[+-]?[0-9]*\.?[0-9]+/g;				return new Point(Number(float.exec(target)), Number(float.exec(target)));			}			else if(local.hasOwnProperty(target))			{				return local[target];			}			else			{				return target + "";			}		}		private function parseParameters(parameters : XMLList, local : Object) : Object		{			var paramObject : Object = {};			for each(var param : XML in parameters)			{				paramObject[param.name().localName] = parseValue(param, local);			}			return paramObject;		}	}}